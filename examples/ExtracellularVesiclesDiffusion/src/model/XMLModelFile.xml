<?xml version="1.0" encoding="utf-8"?>
<gpu:xmodel xmlns:gpu="http://www.dcs.shef.ac.uk/~paul/XMMLGPU" xmlns="http://www.dcs.shef.ac.uk/~paul/XMML">
  
  <name>ExtracellularVesiclesDiffusion</name>

  <gpu:environment>
    <gpu:constants>

      <gpu:variable>
        <type>int</type>
        <name>const_ev_collisions</name>
        <description>Boolean flag to determine at runtime if ev collisions could happen in the simulation</description>
        <defaultValue>1</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>int</type>
        <name>boundaries_enabled</name>
        <description>Boolean flag</description>
        <defaultValue>1</defaultValue>
      </gpu:variable>
      
      <gpu:variable>
        <type>float</type>
        <name>const_Boltzmann</name>
        <description>Boltzmann constant</description>
        <defaultValue>1.3806504e-23f</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>float</type>
        <name>const_Temperature_K</name>
        <description>Temperature (Kelvins) (20-25C) + 237.15</description>
        <defaultValue>293.15f</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>float</type>
        <name>const_Boltzmann_x_Temp_K</name>
        <description>Value needed for computing the diffusion rate</description>
        <defaultValue>4.0473766476e-21</defaultValue>
      </gpu:variable>
      
      <gpu:variable>
        <type>float</type>
        <name>const_water_viscosity</name>
        <description>
          Dynamic viscosity of water at 20C, source http://www.viscopedia.com/viscosity-tables/substances/water/
        </description>
        <!-- Other possible values for 21-25C are: 
        0.0009775, 0.0009544, 0.0009321, 0.0009107, 0.00089 -->
        <defaultValue>0.0010016f</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>float</type>
        <name>const_6_pi_viscosity</name>
        <description>Value required for computing viscosity and drag</description>
      </gpu:variable>
      <gpu:variable>
        <type>float</type>
        <name>const_boltzmann_x_temp</name>
        <description>Value required for computing viscosity and drag</description>
      </gpu:variable>
      <gpu:variable>
        <type>float</type>
        <name>const_pi_4div3</name>
        <description>Precomputed value for 4/3 * Pi</description>
        <defaultValue>4.1887902047863905</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>float</type>
        <name>const_mass_per_volume_unit</name>
        <description>Precomputed value for 100 nm ev mass / 100nm volume</description>
        <defaultValue>1.0465851455395313e-25</defaultValue>
      </gpu:variable>

      <gpu:variable>
        <!-- the number of evs the population must increase by -->
        <type>int</type>
        <name>introduce_n_new_evs</name>
        <defaultValue>0</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>float</type>
        <name>seconds_before_introducing_new_evs</name>
        <defaultValue>0.0f</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>float</type>
        <name>new_evs_threshold</name>
        <defaultValue>1.0f</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>int</type>
        <name>new_evs_random_direction</name>
        <description>Boolean flag</description>
        <defaultValue>0</defaultValue>
      </gpu:variable>
      
      <gpu:variable>
        <type>float</type>
        <name>dt</name>
        <description>The timestep of the model</description>
        <defaultValue>0.003967782</defaultValue>
      </gpu:variable>
      <gpu:variable>
        <type>int</type>
        <name>dof</name>
        <description>Degrees of Freedom in the model</description>
        <defaultValue>1</defaultValue>
      </gpu:variable>
    </gpu:constants>
    <gpu:functionFiles>
      <file>functions.c</file>
    </gpu:functionFiles>

    <gpu:initFunctions>
      <gpu:initFunction>
        <gpu:name>initialize_new_ev_structures</gpu:name>
      </gpu:initFunction>
      <gpu:initFunction>
        <gpu:name>precompute_values</gpu:name>
      </gpu:initFunction>
    </gpu:initFunctions>
    
    <gpu:exitFunctions>
      <gpu:exitFunction>
        <gpu:name>exitFunction</gpu:name>
      </gpu:exitFunction>
    </gpu:exitFunctions>
    
  </gpu:environment>

  <xagents>
    <!-- Secretory cells -->
    <gpu:xagent>
      <name>SecretoryCell</name>
      <memory>
        <gpu:variable>
          <type>unsigned int</type>
          <name>id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>z</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>angle</name>
          <description>angle of inclination with respect to horizon, in RADIANS. For visualisation purposes only</description>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>time_since_last_secreted</name>
        </gpu:variable>
      </memory>
      <functions>
        <gpu:function>
          <name>output_secretory_cell_location</name>
          <description>Adds the cell position to the "location" message list. This list is used for collision detection purposes.</description>
          <currentState>s_default</currentState>
          <nextState>s_default</nextState>
          <outputs>
            <gpu:output>
              <messageName>secretory_cell_location</messageName>
              <gpu:type>single_message</gpu:type>
            </gpu:output>
          </outputs>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>
        
        <!-- add new EVs -->
        <gpu:function>
          <name>secrete_ev</name>
          <description>Introduces a new EV agent into the simulation based on some probabilistic rules.</description>
          <currentState>s_default</currentState>
          <nextState>s_default</nextState>
          <xagentOutputs>
            <gpu:xagentOutput>
              <xagentName>EV</xagentName>
              <state>default</state>
            </gpu:xagentOutput>
          </xagentOutputs>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>true</gpu:RNG>
        </gpu:function>
      </functions>
      <states>
        <gpu:state>
          <name>s_default</name>
        </gpu:state>
        <initialState>s_default</initialState>
      </states>
      <gpu:type>continuous</gpu:type>
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:xagent>
    <!-- Ciliary cells -->
    <gpu:xagent>
      <name>CiliaryCell</name>
      <memory>
        <gpu:variable>
          <type>int</type>
          <name>id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>z</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>angle</name>
          <description>angle of inclination with respect to horizon, in degrees</description>
        </gpu:variable>
      </memory>
      <functions>
        <gpu:function>
          <name>output_ciliary_cell_location</name>
          <description>Adds the cell location to the "location" message list. This list is used for collision detection purposes.</description>
          <currentState>c_default</currentState>
          <nextState>c_default</nextState>
          <outputs>
            <gpu:output>
              <messageName>ciliary_cell_location</messageName>
              <gpu:type>single_message</gpu:type>
            </gpu:output>
          </outputs>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>
      </functions>
      <states>
        <gpu:state>
          <name>c_default</name>
        </gpu:state>
        <initialState>c_default</initialState>
      </states>
      <gpu:type>continuous</gpu:type>
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:xagent>
    
    <!-- EV -->
    <gpu:xagent>
      <name>EV</name>
      <memory>
        <gpu:variable>
          <type>int</type>
          <name>id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>z</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>x_1</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>y_1</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>vx</name>
          <description>The component on X of velocity_um</description>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>vy</name>
          <description>The component on Y of velocity_um</description>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>mass_kg</name>
          <description>Mass of the vesicle in KG</description>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>colour</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>radius_um</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>radius_m</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>diffusion_rate_m</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>diffusion_rate_um</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>diff_rate_um_x_twice_dof</name>
        </gpu:variable>
        <gpu:variable>
          <type>int</type>
          <name>closest_ev_id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>closest_ev_distance</name>
        </gpu:variable>
        <gpu:variable>
          <type>int</type>
          <name>closest_cell_id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>closest_cell_distance</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>age</name>
          <defaultValue>0.003967782</defaultValue>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>velocity_ums</name>
          <description>Velocity in um/s - mean diffusion distance obtained from MSD</description>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>velocity_ms</name>
          <description>Velocity in um/s - mean diffusion distance obtained from MSD</description>
        </gpu:variable>
      </memory>
      <functions>
        <!-- output data -->
        <gpu:function>
          <name>output_data</name>
          <description>Adds the EV's current position to the "location" message list. This list is used for collision detection purposes.</description>
          <currentState>default</currentState>
          <nextState>default</nextState>
          <outputs>
            <gpu:output>
              <messageName>location</messageName>
              <gpu:type>single_message</gpu:type>
            </gpu:output>
          </outputs>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>
        <!-- test secretory cell collision -->
        <gpu:function>
          <name>test_secretory_cell_collision</name>
          <description>Checks for possible collisions with secretory boundaries. Outputs an optional collision_message. EVs colliding with a cell contain the parameter "closest_cell_id" > -1 and have a value on "closest_cell_distance"</description>
          <currentState>default</currentState>
          <nextState>default</nextState>
          <inputs>
            <gpu:input>
              <messageName>secretory_cell_location</messageName>
            </gpu:input>
          </inputs>
          <outputs>
            <gpu:output>
              <messageName>cell_collision</messageName>
              <gpu:type>optional_message</gpu:type>
            </gpu:output>
          </outputs>
          <gpu:globalCondition>
            <lhs>
              <value>boundaries_enabled</value>
            </lhs>
            <operator>></operator>
            <rhs>
              <value>0</value>
            </rhs>
            <gpu:maxItterations>10000000</gpu:maxItterations>
            <gpu:mustEvaluateTo>true</gpu:mustEvaluateTo>
          </gpu:globalCondition>
          
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>
        <!-- test ciliary cell collision -->
        <gpu:function>
          <name>test_ciliary_cell_collision</name>
          <description>Checks for possible collisions with ciliary boundaries. Outputs an optional collision_message. EVs colliding with a cell contain the parameter "closest_cell_id" > -1 and have a value on "closest_cell_distance"</description>
          <currentState>default</currentState>
          <nextState>default</nextState>
          <inputs>
            <gpu:input>
              <messageName>ciliary_cell_location</messageName>
            </gpu:input>
          </inputs>
          <outputs>
            <gpu:output>
              <messageName>ciliary_cell_collision</messageName>
              <gpu:type>optional_message</gpu:type>
            </gpu:output>
          </outputs>

          <gpu:globalCondition>
            <lhs>
              <value>boundaries_enabled</value>
            </lhs>
            <operator>></operator>
            <rhs>
              <value>0</value>
            </rhs>
            <gpu:maxItterations>10000000</gpu:maxItterations>
            <gpu:mustEvaluateTo>true</gpu:mustEvaluateTo>
          </gpu:globalCondition>
          
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>
        <!-- test ev collision -->
        <gpu:function>
          <name>test_ev_collision</name>
          <description>Checks for possible collisions with other EVs. Outputs an optional collision_message. EVs colliding with another EV contain the parameter "closest_ev_id" > -1 and have a value on "closest_ev_distance"</description>
          <currentState>default</currentState>
          <nextState>default</nextState>
          <inputs>
            <gpu:input>
              <messageName>location</messageName>
            </gpu:input>
          </inputs>
          <outputs>
            <gpu:output>
              <messageName>ev_collision</messageName>
              <gpu:type>optional_message</gpu:type>
            </gpu:output>
          </outputs>
          <gpu:globalCondition>
            <lhs>
              <value>const_ev_collisions</value>
            </lhs>
            <operator>></operator>
            <rhs>
              <value>0</value>
            </rhs>
            <gpu:maxItterations>1000000</gpu:maxItterations>
            <gpu:mustEvaluateTo>true</gpu:mustEvaluateTo>
          </gpu:globalCondition>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>
        <!-- ev collision resolution -->
        <gpu:function>
          <name>ev_collision_resolution</name>
          <description>Corrects the position of an EV involved in a collision with another EV. This function applies to EVs with variable "closest_ev_id" > -1</description>
          <currentState>default</currentState>
          <nextState>collision_resolved</nextState>
          <inputs>
            <gpu:input>
              <messageName>ev_collision</messageName>
            </gpu:input>
          </inputs>
          <!-- check there is an ev collision only or it happens before the cell collision -->
          <condition>
            <lhs>
              <condition>
                <!-- closest_ev_id &gt; -1 -->
                <lhs>
                  <agentVariable>closest_ev_id</agentVariable>
                </lhs>
                <operator>&gt;</operator>
                <rhs>
                  <value>-1</value>
                </rhs>
              </condition>
            </lhs>
            <operator>&amp;&amp;</operator>
            <rhs>
              <condition>
                <lhs>
                  <condition>
                   <!-- closest_cell_id == -1 -->
                    <lhs>
                      <agentVariable>closest_cell_id</agentVariable>
                    </lhs>
                    <operator>==</operator>
                    <rhs>
                      <value>-1</value>
                    </rhs>
                  </condition>
                </lhs>
                <operator>||</operator>
                <rhs>
                  <condition>
                    <lhs>
                      <condition>
                        <lhs>
                          <agentVariable>closest_cell_id</agentVariable>
                        </lhs>
                        <operator>!=</operator>
                        <rhs>
                          <value>-1</value>
                        </rhs>
                      </condition>
                    </lhs>
                    <operator>&amp;&amp;</operator>
                    <rhs>
                      <condition>
                        <!--  TODO also check closest_cell_id <> -1 closest_ev_distance &lt; closest_cell_distance -->
                        <lhs>
                          <agentVariable>closest_ev_distance</agentVariable>
                        </lhs>
                        <operator>&lt;</operator>
                        <rhs>
                          <agentVariable>closest_cell_distance</agentVariable>
                        </rhs>
                      </condition>
                    </rhs>
                  </condition>
                  
                </rhs>
              </condition>
            </rhs>
          </condition>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>  
        <!-- cell collision resolution -->
        <gpu:function>
          <name>cell_collision_resolution</name>
          <description>Corrects the position of an EV as a result of colliding with a cell. This function only applies to EVs with variable "closest_cell_id" &gt; -1 &amp; (closest_ev_id == -1 || closest_cell_distance &lt; closest_ev_distance)</description>
          <currentState>default</currentState>
          <nextState>collision_resolved</nextState>
          <inputs>
            <gpu:input>
              <messageName>cell_collision</messageName>
            </gpu:input>
          </inputs>
          <!-- check there is a cell collision only or it happens before the ev collision -->
          <condition>
            <lhs>
              <condition>
                <lhs><agentVariable>closest_cell_id</agentVariable></lhs>
                <operator>></operator>
                <rhs><value>-1</value></rhs>
              </condition>
            </lhs>
            <operator>&amp;&amp;</operator>
            <rhs>
              <condition>
                <lhs>
                  <condition>
                    <lhs>
                      <agentVariable>closest_ev_id</agentVariable>
                    </lhs>
                    <operator>==</operator>
                    <rhs>
                      <value>-1</value>
                    </rhs>
                  </condition>
                </lhs>
                <operator>||</operator>
                <rhs>
                  <condition>
                    <lhs>
                      <condition>
                        <lhs>
                          <agentVariable>closest_ev_id</agentVariable>
                        </lhs>
                        <operator>!=</operator>
                        <rhs>
                          <value>-1</value>
                        </rhs>
                      </condition>
                    </lhs>
                    <operator>&amp;&amp;</operator>
                    <rhs>
                      <condition>
                        <lhs>
                          <agentVariable>closest_cell_distance</agentVariable>
                        </lhs>
                        <operator>&lt;</operator>
                        <rhs>
                          <agentVariable>closest_ev_distance</agentVariable>
                        </rhs>
                      </condition>
                    </rhs>
                  </condition>
                </rhs>
              </condition>
            </rhs>
          </condition>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>
        <!-- ciliary_cell collision resolution -->
        <gpu:function>
          <name>ciliary_cell_collision_resolution</name>
          <description>Corrects the position of an EV as a result of colliding with a ciliary cell. This function only applies to EVs with variable "closest_cell_id" &gt; -1 &amp; (closest_ev_id == -1 || closest_cell_distance &lt; closest_ev_distance)</description>
          <currentState>default</currentState>
          <nextState>collision_resolved</nextState>
          <inputs>
            <gpu:input>
              <messageName>ciliary_cell_collision</messageName>
            </gpu:input>
          </inputs>
          <!-- check there is a cell collision only or it happens before the ev collision -->
          <condition>
            <lhs>
              <condition>
                <lhs>
                  <agentVariable>closest_cell_id</agentVariable>
                </lhs>
                <operator>></operator>
                <rhs>
                  <value>-1</value>
                </rhs>
              </condition>
            </lhs>
            <operator>&amp;&amp;</operator>
            <rhs>
              <condition>
                <lhs>
                  <condition>
                    <lhs>
                      <agentVariable>closest_ev_id</agentVariable>
                    </lhs>
                    <operator>==</operator>
                    <rhs>
                      <value>-1</value>
                    </rhs>
                  </condition>
                </lhs>
                <operator>||</operator>
                <rhs>
                  <condition>
                    <lhs>
                      <condition>
                        <lhs>
                          <agentVariable>closest_ev_id</agentVariable>
                        </lhs>
                        <operator>!=</operator>
                        <rhs>
                          <value>-1</value>
                        </rhs>
                      </condition>
                    </lhs>
                    <operator>&amp;&amp;</operator>
                    <rhs>
                      <condition>
                        <lhs>
                          <agentVariable>closest_cell_distance</agentVariable>
                        </lhs>
                        <operator>&lt;</operator>
                        <rhs>
                          <agentVariable>closest_ev_distance</agentVariable>
                        </rhs>
                      </condition>
                    </rhs>
                  </condition>
                </rhs>
              </condition>
            </rhs>
          </condition>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>false</gpu:RNG>
        </gpu:function>

        <!-- brownian movement affecting the agent -->
        <gpu:function>
          <name>brownian_movement_1d</name>
          <currentState>default</currentState>
          <nextState>default</nextState>
          <gpu:globalCondition>
            <lhs>
              <value>dof</value>
            </lhs>
            <operator>==</operator>
            <rhs>
              <value>1</value>
            </rhs>
            <gpu:maxItterations>1000000</gpu:maxItterations>
            <gpu:mustEvaluateTo>true</gpu:mustEvaluateTo>
          </gpu:globalCondition>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>true</gpu:RNG>
        </gpu:function>
        <gpu:function>
          <name>brownian_movement_2d</name>
          <currentState>default</currentState>
          <nextState>default</nextState>
          <gpu:globalCondition>
            <lhs>
              <value>dof</value>
            </lhs>
            <operator>==</operator>
            <rhs>
              <value>2</value>
            </rhs>
            <gpu:maxItterations>1000000</gpu:maxItterations>
            <gpu:mustEvaluateTo>true</gpu:mustEvaluateTo>
          </gpu:globalCondition>
          <gpu:reallocate>false</gpu:reallocate>
          <gpu:RNG>true</gpu:RNG>
        </gpu:function>
        <!-- reset agent state -->
        <gpu:function>
          <name>reset_state</name>
          <currentState>collision_resolved</currentState>
          <nextState>default</nextState>
          <gpu:reallocate>false</gpu:reallocate>
        </gpu:function>
        
        <!-- move -->
        <gpu:function>
          <name>move</name>
          <currentState>default</currentState>
          <nextState>default</nextState>
          <gpu:reallocate>false</gpu:reallocate>
        </gpu:function>
      </functions>
      
      <states>
        <gpu:state>
          <name>default</name>
        </gpu:state>
        <gpu:state>
          <name>initial</name>
        </gpu:state>
        <gpu:state>
          <name>collision_resolved</name>
        </gpu:state>
        <initialState>default</initialState>
      </states>
      <gpu:type>continuous</gpu:type>
      <!-- 2^17=131072, 2^16=65536, 1^15=32768, 2^14=16384, 2^13=8192 2^12= 4095, 2^11=2048
      2^18=262144, 2^19=524288, 2^20=1048576, -->
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:xagent>
  </xagents>
  
  <messages>
    <!-- location -->
    <gpu:message>
      <name>location</name>
      <variables>
        <gpu:variable>
          <type>int</type>
          <name>id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>z</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>radius_um</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>mass_kg</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>vx</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>vy</name>
        </gpu:variable>
      </variables>
      <gpu:partitioningSpatial>
        <gpu:radius>1</gpu:radius>
        <gpu:xmin>0</gpu:xmin>
        <gpu:xmax>3000</gpu:xmax>
        <gpu:ymin>0</gpu:ymin>
        <gpu:ymax>4000</gpu:ymax>
        <gpu:zmin>0</gpu:zmin>
        <gpu:zmax>1</gpu:zmax>
      </gpu:partitioningSpatial>
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:message>
    <!-- secretory cell_location -->
    <gpu:message>
      <name>secretory_cell_location</name>
      <variables>
        <gpu:variable>
          <type>int</type>
          <name>id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>z</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_y</name>
        </gpu:variable>
        
        <gpu:variable>
          <type>float</type>
          <name>direction_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_y</name>
        </gpu:variable>
      </variables>
      <gpu:partitioningSpatial>
        <gpu:radius>1</gpu:radius>
        <gpu:xmin>0</gpu:xmin>
        <gpu:xmax>3000</gpu:xmax>
        <gpu:ymin>0</gpu:ymin>
        <gpu:ymax>4000</gpu:ymax>
        <gpu:zmin>0</gpu:zmin>
        <gpu:zmax>1</gpu:zmax>
      </gpu:partitioningSpatial>
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:message>
    <!-- ciliary cell_location -->
    <gpu:message>
      <name>ciliary_cell_location</name>
      <variables>
        <gpu:variable>
          <type>int</type>
          <name>id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>z</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_y</name>
        </gpu:variable>

        <gpu:variable>
          <type>float</type>
          <name>direction_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_y</name>
        </gpu:variable>
      </variables>
      <gpu:partitioningSpatial>
        <gpu:radius>1</gpu:radius>
        <gpu:xmin>0</gpu:xmin>
        <gpu:xmax>3000</gpu:xmax>
        <gpu:ymin>0</gpu:ymin>
        <gpu:ymax>4000</gpu:ymax>
        <gpu:zmin>0</gpu:zmin>
        <gpu:zmax>1</gpu:zmax>
      </gpu:partitioningSpatial>
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:message>
    
    <!-- ev collision -->
    <gpu:message>
      <name>ev_collision</name>
      <variables>
        <gpu:variable>
          <type>int</type>
          <name>ev1_id</name>
        </gpu:variable>
        <gpu:variable>
          <type>int</type>
          <name>ev2_id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>distance</name>
        </gpu:variable>
        
        <gpu:variable>
          <type>float</type>
          <name>ev1_mass</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev1_r_um</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev1_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev1_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev1_vx</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev1_vy</name>
        </gpu:variable>

        <gpu:variable>
          <type>float</type>
          <name>ev2_mass</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev2_r_um</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev2_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev2_y</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev2_vx</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>ev2_vy</name>
        </gpu:variable>
        
      </variables>
      <gpu:partitioningNone/>
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:message>
    <!-- cell collision message -->
    <gpu:message>
      <name>ciliary_cell_collision</name>
      <variables>
        <gpu:variable>
          <type>int</type>
          <name>ev_id</name>
        </gpu:variable>
        <gpu:variable>
          <type>int</type>
          <name>cell_id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>distance</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_x</name>
          <description>cell p1</description>
          <defaultValue>-1</defaultValue>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_y</name>
          <defaultValue>-1</defaultValue>
        </gpu:variable>
         <gpu:variable>
          <type>float</type>
          <name>p2_x</name>
          <description>cell p1</description>
          <defaultValue>-1</defaultValue>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_y</name>
          <defaultValue>-1</defaultValue>
        </gpu:variable>
        
        <gpu:variable>
          <type>float</type>
          <name>direction_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_y</name>
        </gpu:variable>
        <!-- for cells ends -->
      </variables>
      <gpu:partitioningNone/>
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:message>
    <!-- cell collision message -->
    <gpu:message>
      <name>cell_collision</name>
      <variables>
        <gpu:variable>
          <type>int</type>
          <name>ev_id</name>
        </gpu:variable>
        <gpu:variable>
          <type>int</type>
          <name>cell_id</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>distance</name>
        </gpu:variable>
        
        <gpu:variable>
          <type>float</type>
          <name>p1_x</name>
          <description>cell p1</description>
          <defaultValue>-1</defaultValue>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p1_y</name>
          <defaultValue>-1</defaultValue>
        </gpu:variable>
         <gpu:variable>
          <type>float</type>
          <name>p2_x</name>
          <description>cell p1</description>
          <defaultValue>-1</defaultValue>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>p2_y</name>
        </gpu:variable>
        
        <gpu:variable>
          <type>float</type>
          <name>direction_x</name>
        </gpu:variable>
        <gpu:variable>
          <type>float</type>
          <name>direction_y</name>
        </gpu:variable>
        <!-- for cells ends -->
      </variables>
      <gpu:partitioningNone/>
      <gpu:bufferSize>1048576</gpu:bufferSize>
    </gpu:message>
  </messages>
  
  <layers>
    <layer>
      <gpu:layerFunction><name>secrete_ev</name></gpu:layerFunction>
    </layer>
    <layer>
      <!-- Create a message to communicate the EVs current positions -->
      <gpu:layerFunction><name>output_data</name></gpu:layerFunction>
    </layer>
    <layer>
      <gpu:layerFunction><name>output_ciliary_cell_location</name></gpu:layerFunction>
    </layer>
    <layer>
      <gpu:layerFunction><name>output_secretory_cell_location</name></gpu:layerFunction>
    </layer>
    <layer>
      <!-- Find the closest collision with the boundaries or other EVs-->
      <gpu:layerFunction><name>test_secretory_cell_collision</name></gpu:layerFunction>
    </layer>
    <layer>
      <gpu:layerFunction><name>test_ciliary_cell_collision</name></gpu:layerFunction>
    </layer>
    <layer>
      <gpu:layerFunction><name>test_ev_collision</name></gpu:layerFunction>
    </layer>
    <layer>
      <!-- Solve collisions with secretory cells -->
      <gpu:layerFunction><name>cell_collision_resolution</name></gpu:layerFunction>
    </layer>
    <layer>
      <!-- Solve collisions with ciliary cells -->
      <gpu:layerFunction><name>ciliary_cell_collision_resolution</name></gpu:layerFunction>
    </layer>
    <layer>
      <!-- Solve inter vesicle collisions -->
      <gpu:layerFunction><name>ev_collision_resolution</name></gpu:layerFunction>
    </layer>
    <layer>
      <!-- Vesicles not involved in a collision -->
      <gpu:layerFunction><name>brownian_movement_1d</name></gpu:layerFunction>
      <gpu:layerFunction><name>brownian_movement_2d</name></gpu:layerFunction>
    </layer>
    <layer>
      <!-- Vesicles involved in a collision -->
      <gpu:layerFunction><name>reset_state</name></gpu:layerFunction>
    </layer>
    
    <layer>
      <!-- Advance the simulation by a single timestep -->
      <gpu:layerFunction><name>move</name></gpu:layerFunction>
    </layer>
  </layers>

</gpu:xmodel>
